# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/128lK0yNT-IrD27qrVtjQlWym4X4KcUZX
"""



from tqdm import tqdm
from pathlib import Path
import pandas as pd
import numpy as np
from scipy.optimize import curve_fit
from __future__ import absolute_import, division, print_function, unicode_literals

import tensorflow as tf

tf.keras.backend.clear_session()
import warnings
warnings.filterwarnings('ignore')

FORECAST_HORIZON = 90  # 90 days


def hyperbolic_equation(t: float, qi: float, b: float, di: float) -> float:
   
    return qi / ((1.0 + b * di * t) ** (1.0 / b))



def make_prediction(historical_values: pd.DataFrame,
                    forecast_horizon: int = FORECAST_HORIZON) -> pd.DataFrame:
   
    time_series = historical_values['Дебит нефти'].values
    peak_index = np.argmax(time_series)
    qi = time_series[peak_index]

    latest_period = time_series[peak_index:]
    days = [i for i in range(1, len(latest_period) + 1)]

    popt, pcov = curve_fit(hyperbolic_equation, days, latest_period, bounds=(0, [qi, 2, 20]))
    import matplotlib.pyplot as plt
    plt.plot(days, latest_period, label='real')
    plt.plot(days, hyperbolic_equation(np.array(days, dtype=float), *popt), label='estimated')
    plt.legend()
    plt.show()

    qi, b, di = popt
    print(f'Fit Curve Variables: qi={qi}, b={b}, di={di}')

    pred_start = max(days) + 1
    pred_end = pred_start + forecast_horizon
    pred_days = np.array([i for i in range(pred_start, pred_end)], dtype=np.float)
    forecast = hyperbolic_equation(pred_days, *popt)

    date_range = pd.date_range(start='1992-04-11', freq='1D', periods=forecast_horizon)
    forecast_df = pd.DataFrame({'datetime': date_range, 'forecast': forecast})
    

    return forecast_df
 

def process_data():
    """Function loads training data from file and
    iterates over unique wells in the dataset
    making forecast for each time series.
    """
    train_path = Path().cwd().parent /'content'/'train.csv'
    train_df = pd.read_csv(train_path)
    print(f'Loaded training data. Shape: {train_df.shape}')

    wells = list(train_df['Номер скважины'].unique())
    print(f'Number of unique wells: {len(wells)}')

    all_forecasts = []
    with tqdm(total=len(wells)) as pbar:
        for well in wells:
            print(f'Started processing well ID: {well}')
            well_df = train_df[train_df['Номер скважины'] == well]

            # Make prediction using Decline Curve Analysis
            forecats_df = make_prediction(well_df)
            forecats_df['Номер скважины'] = [well] * len(forecats_df)
            all_forecasts.append(forecats_df)

            pbar.update(1)

    all_forecasts = pd.concat(all_forecasts)
    print(f'Completed data processing. Forecast shape: {all_forecasts.shape}')
    print(f'Number of unique wells: {len(all_forecasts["Номер скважины"].unique())}')

    all_forecasts.to_csv('train_forecast.csv', index=False, encoding="utf-8")
    print('Saved forecast to "train_forecast.csv"')


if __name__ == '__main__':
    process_data()

!pip3 install catboost

import numpy as np
from catboost import Pool, CatBoostRegressor
# initialize data
train_data = np.random.randint(0, 
                               100, 
                               size=(100, 10))
train_label = np.random.randint(0, 
                                1000, 
                                size=(100))
test_data = np.random.randint(0, 
                              100, 
                              size=(50, 10))
# initialize Pool
train_pool = Pool(train_data, 
                  train_label, 
                  cat_features=[0,2,5])
test_pool = Pool(test_data, 
                 cat_features=[0,2,5]) 

# specify the training parameters 
model = CatBoostRegressor(iterations=2, 
                          depth=2, 
                          learning_rate=1, 
                          loss_function='RMSE')
#train the model
model.fit(train_pool)
# make the prediction using the resulting model
preds = model.predict(test_pool)
print(preds)